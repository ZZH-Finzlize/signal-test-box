# 信号实验箱

本软件为一个基于表达式的信号计算、绘图软件,主要功能为对输入的信号进行采样,然后对采样序列进行各种运算,并将运算结果绘制为波形

- [1. 工作原理](#1-工作原理)
- [2. 信号定义](#2-信号定义)
- [3. 内置编译器](#3-内置编译器)
- [4. 已知的不足](#4-已知的不足)

## 1. 工作原理

1. 一个信号可用一个表达式f进行描述,在任意的t时刻,信号的强度为f(t)
2. 若给定某时刻t,则表达式f(t)的运算结果即为信号f在t时刻的信号强度采样值
3. t可根据软件内设置的采样频率计算得出,然后重复采样N次,N为软件内设置的采样点数
4. 软件在计算前会将要计算的信号的表达式编译为语法树
5. 语法树内每个节点在计算自身的值之前,会先将子节点的值计算出来,因此根节点的计算值即为表达式整体的值
6. 然后重复计算根节点的值,便得到采样序列
7. 若自定义信号之间存在相互引用,则内层信号将会先运算得到运算值,然后再进行外层信号的运算
8. 信号存在最大嵌套层数限制,防止某信号引用自身或者多个信号交叉引用造成无限递归的情况

## 2. 信号定义

在软件内所有的信号定义均为表达式形式,例如sin(t)便是代表了经过数字采样的sin信号,sin(100*t) + sin(200*t)便是将两个频率不同的信号叠加  

信号间可以相互引用,例如sig0 = sin(100*t) sig1 = sin(200*t) sig2 = sig0+sig1  

信号自身引用自身或交叉引用均会触发最大嵌套限制

## 3. 内置编译器

软件内置一个简单的编译器,此编译器内置了信号常用的数学函数,包括sin、cos、rand、hrand、max、min,
其中的rand是C语言标准库的随机函数,hrand是CPU硬件随机数,使用了x86指令集中的随机数指令rdrand实现,因此有可能有些机器不支持

编译器支持一个特殊变量t,代表当前的时间,也就是第n次采样除以采样频率fs, t = n/fs

编译器支持一个常量pi,代表圆周率

编译器对于符号的处理和解析是大小写无关的,pi等价PI Pi pI,t也等价于T

## 4. 已知的不足

1. 信号之间的引用是通过"N次编译"的过程实现的,第一次编译的是当前表达式,当前表达式内的其他信号会再次编译,嵌套N层就存在N次编译,然后合并语法树后再计算,缺陷虽然不是很明显,但是个人认为这样做并不是最合适的
   - 优化方案1: 将信号引用表达式递归展开,最终合并为一个表达式,一次编译即可得到可用于计算的语法树
   >优点: 逻辑清晰,省去了二次编译  
   >改动组件: 词法分析器(位置追踪、Input输入、symbol规则的动作)  
   >缺点: 位置追踪可能会麻烦点,没有利用曾经编译过的语法树
   - 优化方案2:ui的信号列表model里存扩展的item对象,对象内同时保存文本和编译后的语法树,当文本表达式更新后再挑选合适时机重新编译更新语法树
   >优点: 省去了二次编译,能够重复利用之前的编译信息  
   >改动组件: ui(QListWidget相关的操作、QListWidgetItem派生类)  
   >缺点: 位置追踪逻辑基本不变,计算前的处理逻辑会更复杂

2. 编译器产生的语法树没有优化
    - 优化方案1: 改动文法,将常量表达式搬到编译期求值
    >优点: 改动小,实现简单  
    >改动组件: 语法分析器(信号表达式文法、常量表达式文法及规约动作)  
    >缺点: 只能将常量表达式进行优化,且不能利用交换律进行更进一步的优化
    - 优化方案2: 改动语法树,加入通常编译器的数据流分析优化
    >优点: 优化力度更强,更符合常规编译器的设计结构  
    >改动组件: 抽象语法树(语法节点及整体结构)  
    >缺点: 编译逻辑会复杂很多,并且会造成软件体积增大

3. 编译器调用函数没有进行参数检查
   - 优化方案1: 增加外部的函数库描述文件,对每个函数进行参数数量和类型描述,载入库时将描述信息存入符号表
    (目前只有一种数据类型,也没有外部库支持,此方案暂时还做不了)

4. 缺少外部动态库扩展功能,因此只能使用内置函数进行运算

5. 只有float一种数据类型的支持,而信号处理不可避免的会涉及向量(复数)类型

6. 目前的计算方式是逐点计算,输入值为时间,对于常规的信号表达式没有问题,但如果使用傅里叶变换这种需要采样序列作为输入的函数,逐点计算如何实现?
    - 优化方案1: 可参考matlab的处理,将基本数据类型设定为向量,这样一来基本的函数输入输出均为向量类型,就可以和各种需要采样序列的函数兼容
